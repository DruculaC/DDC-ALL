C51 COMPILER V9.51   COMMUNICATION                                                         09/30/2014 11:22:45 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE COMMUNICATION
OBJECT MODULE PLACED IN .\communication.obj
COMPILER INVOKED BY: D:\Program Files (x86)\keil\C51\BIN\C51.EXE ..\Library\communication.c BROWSE INCDIR(..\Library) DE
                    -BUG OBJECTEXTEND PRINT(.\communication.lst) OBJECT(.\communication.obj)

line level    source

   1          /*---------------------------------------------------
   2                  communication.c (v1.00)
   3                  
   4                  通信程序
   5          ---------------------------------------------------*/   
   6          
   7          #include "main.h"
   8          #include "port.h"
   9          
  10          #include "communication.h"
  11          #include "Delay.h"
  12          
  13          /*------ private variable --------------------------*/
  14          tByte myTxRxData[7]={0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  15          
  16          /*------- Public variable declarations --------------------------*/
  17          extern tByte receive_LV_count;          
  18          extern bit receive_wire_flag;           
  19          extern tByte one_receive_byte;          
  20          extern tByte one_receive_byte_count;                    
  21          extern tByte receive_HV_count;          
  22          extern tByte data_count;                                
  23          extern tByte received_data_buffer[7];           
  24          extern bit receive_data_finished_flag;          
  25          
  26          /*----------------------------------------------------
  27                  initsignal()
  28                  
  29                  初始化信号程序，接收机在接接收信号的时候，需要有
  30                  一段代码来使接收机打开，而这一段程序有可能无法识别
  31                  出来，而是相当于废代码，只占用通信时间。
  32          ----------------------------------------------------*/
  33          void initsignal()
  34                  {
  35   1              tByte k,k1;
  36   1              tByte mystartbuffer = 0xaa;
  37   1              for(k1 = 0; k1 < 3; k1++)
  38   1                      {
  39   2                      for(k=0;k<8;k++)
  40   2                              {
  41   3                              if((mystartbuffer&0x80) == 0x80)//为1
  42   3                                      {
  43   4                                      P10=0;
  44   4                                      Custom_Delay(23, 21);
  45   4                                      }
  46   3                              else
  47   3                                      {
  48   4                                      P10=0;
  49   4                                      Custom_Delay(23, 21);
  50   4                                      }
  51   3                              P10=1;
  52   3                              mystartbuffer<<=1;
  53   3                              Custom_Delay(43, 21);
  54   3                              }
C51 COMPILER V9.51   COMMUNICATION                                                         09/30/2014 11:22:45 PAGE 2   

  55   2                      mystartbuffer=0xaa;
  56   2                      Custom_Delay(23, 21);
  57   2                      }
  58   1              P10=1;
  59   1              }
  60          
  61          /*--------------------------------------------------
  62                  Send_Data()
  63                  将数据发送出去
  64          --------------------------------------------------*/
  65          void Send_Data(tByte x)
  66                  {
  67   1              tByte i,n;
  68   1              for(i=0;i<3;i++)
  69   1                      {
  70   2                      for(n=0;n<8;n++)
  71   2                              {
  72   3                              if((myTxRxData[i]&0x80)==0x80)
  73   3                                      {
  74   4                                      P10=0;
  75   4                                      Custom_Delay(36, x);
  76   4                                      }
  77   3                              else
  78   3                                      {
  79   4                                      P10=0;
  80   4                                      Custom_Delay(23, x);
  81   4                                      }
  82   3                              P10=1;
  83   3                              myTxRxData[i]<<=1;
  84   3                              Custom_Delay(15, x);
  85   3                              }
  86   2                      }       
  87   1              }
  88          
  89          /*--------------------------------------------------
  90                  ComMode_Data()
  91                  
  92                  主机接收到编码1信号后，会反馈一个编码1信号给附机
  93                  以表示主机在附机附近。
  94          ---------------------------------------------------*/
  95          void ComMode_Data(tByte ComMode, x)     
  96                  {
  97   1              receiver_EN = 1;
  98   1              transmiter_EN = 0;
  99   1              myTxRxData[0] = CmdHead;
 100   1              myTxRxData[1] = MyAddress;
 101   1              myTxRxData[2] = ComMode;
 102   1      
 103   1              initsignal();
 104   1          Send_Data(x);
 105   1              
 106   1              transmiter_EN = 1;
 107   1              receiver_EN = 0;
 108   1              }
 109          
 110          /*-----------------------------------------------------------------------------
 111                  receive_byte()
 112                  receive a byte program
 113          -----------------------------------------------------------------------------*/
 114          void receive_byte(void)
 115                  {
 116   1              // P11 constantly HV, if detected a LV, judge it.
C51 COMPILER V9.51   COMMUNICATION                                                         09/30/2014 11:22:45 PAGE 3   

 117   1              if(P11 == 0)
 118   1                      {
 119   2                      // count the LV time, if more than 12ms, reset it.
 120   2                      if(++receive_LV_count == 120)
 121   2                              {
 122   3                              receive_LV_count = 0;
 123   3                              }
 124   2                      receive_wire_flag = 0;
 125   2                      }
 126   1              // if P11 return to HV
 127   1              else
 128   1                      {
 129   2                      // and already have LV before, so we think it maybe a bit signal
 130   2                      if(receive_wire_flag == 0)
 131   2                              {
 132   3                              // set the flag, to judge a bit only one time
 133   3                              receive_wire_flag = 1;
 134   3      
 135   3                              // judge the LV time, if 3.5ms < time < 8ms, we think it is a "0". time<3.5ms means a noise.
 136   3                              if((receive_LV_count > 35)&&(receive_LV_count <= 80))   
 137   3                                      {
 138   4                                      // save "0" to one byte
 139   4                                      one_receive_byte <<= 1;
 140   4                                      one_receive_byte &= 0xfe;
 141   4                                      one_receive_byte_count++;
 142   4                                      receive_HV_count = 0;
 143   4                                      }
 144   3                              // time > 8ms, means a "1"
 145   3                              else if((receive_LV_count > 80))
 146   3                                      {
 147   4                                      // save "1" to one byte
 148   4                                      one_receive_byte <<= 1;
 149   4                                      one_receive_byte |= 0x01;
 150   4                                      one_receive_byte_count++;
 151   4                                      receive_HV_count = 0;
 152   4                                      }
 153   3                              
 154   3                              else
 155   3                                      {
 156   4                                      // increase the count for HV
 157   4                                      receive_HV_count++;     
 158   4                                      }
 159   3               // reset LV count
 160   3                              receive_LV_count = 0;
 161   3                              }
 162   2                      else
 163   2                              {
 164   3                              // judge whether HV count > 6ms, if yes, means a restart
 165   3                              if(++receive_HV_count >= 60)
 166   3                                      {
 167   4                                      one_receive_byte_count = 0;
 168   4                                      receive_wire_flag = 1;
 169   4                                      data_count = 0;
 170   4                                      }               
 171   3                              }
 172   2                      }
 173   1              }
 174          
 175          /*-----------------------------------------------------------------------------
 176                  receive_word()
 177                  receive a word program
 178          -----------------------------------------------------------------------------*/
C51 COMPILER V9.51   COMMUNICATION                                                         09/30/2014 11:22:45 PAGE 4   

 179          void receive_word(void)
 180                  {
 181   1              // one byte have 8 bit, once receive a bit, the count increase, once it is 8, it means a byte received.
 182   1              if(one_receive_byte_count == 8)
 183   1                      {
 184   2                      one_receive_byte_count = 0;
 185   2                      // assign one byte to buffer[i] 
 186   2                      received_data_buffer[data_count] = one_receive_byte;
 187   2                      
 188   2                      // judge whether buffer[0] is CmdHead
 189   2                      if((data_count == 0) && (received_data_buffer[0] == CmdHead))
 190   2                              {
 191   3                              data_count = 1;
 192   3                              }
 193   2                      // judge whether buffer[1] is MyAddress
 194   2                      else if((data_count == 1) && (received_data_buffer[1] == MyAddress))
 195   2                              {
 196   3                              data_count = 2;
 197   3                              }
 198   2                      else if(data_count == 2)
 199   2                              {
 200   3                              receive_data_finished_flag = 1;
 201   3                              data_count = 0;
 202   3                              }
 203   2                      else 
 204   2                              {
 205   3                              data_count = 0;
 206   3                              }
 207   2                      }
 208   1              }
 209          
 210          /*--------------------------------------------------
 211                  send_code_to_lock()
 212                  
 213                  将密码发送给锁体。
 214          ---------------------------------------------------*/
 215          void send_code_to_lock(tByte x, y)      
 216          {
 217   1              unsigned char i,n;
 218   1              myTxRxData[0]=CmdHead;
 219   1              myTxRxData[1]=MyAddress;
 220   1              myTxRxData[2]=x;
 221   1      /*      myTxRxData[3]=0x00;
 222   1              myTxRxData[4]=0x00;
 223   1              myTxRxData[5]=0x00;
 224   1              myTxRxData[6]=0x00;
 225   1      */
 226   1              for(i=0;i<3;i++)
 227   1              {
 228   2                      for(n=0;n<8;n++)
 229   2                      {
 230   3                              if((myTxRxData[i]&0x80) == 0x80)//为1
 231   3                              {
 232   4                                      MagentControl_1 = 0;
 233   4                                      Custom_Delay(36, y);
 234   4                              }
 235   3                              else//为0的情况
 236   3                              {
 237   4                                      MagentControl_1 = 0;
 238   4                                      Custom_Delay(23, y);
 239   4                              }
 240   3                              MagentControl_1 = 1;            //常态为高电平
C51 COMPILER V9.51   COMMUNICATION                                                         09/30/2014 11:22:45 PAGE 5   

 241   3                              myTxRxData[i] <<= 1;
 242   3                              Custom_Delay(15, y);
 243   3                      }
 244   2              }
 245   1      }
 246                  
 247          /*---------------------------------------------------
 248                  end of file
 249          ----------------------------------------------------*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    423    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
